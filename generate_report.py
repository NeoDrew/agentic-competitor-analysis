#!/usr/bin/env python3
"""
Generate a Professional Sentinel Report using LaTeX.
Requirements: pdflatex (Mac: brew install --cask basictex)
"""
import argparse
import os
import time
import subprocess
import shutil
import urllib.parse
import json
import re
from datetime import datetime
import requests

# --- LaTeX Template (Universal Fonts) ---
LATEX_TEMPLATE = r"""
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}      % Critical for Mac BasicTeX
\usepackage{lmodern}          % Universal Vector Font (Guaranteed to exist)
\usepackage[margin=1in]{geometry}
\usepackage{xcolor}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{array}
\usepackage{textcomp}         % For currency symbols like $

% Define Colors
\definecolor{navy}{RGB}{10, 25, 60}
\definecolor{sentinelred}{RGB}{200, 30, 30}
\definecolor{grey}{RGB}{100, 100, 100}

% Custom commands
\newcommand{\sectionheader}[1]{{\large\textbf{\textcolor{navy}{#1}}}}

\title{\textbf{Sentinel Strategic Alert}}
\date{}

\begin{document}

% --- Header ---
\noindent
{\Huge \textbf{Sentinel Strategic Alert: \textcolor{navy}{<<COMPETITOR>>}}} \\
{\small \textcolor{grey}{Generated: <<TIMESTAMP>>}}

\vspace{0.8cm}

% --- Verdict ---
\noindent
\colorbox{navy!10}{\parbox{\dimexpr\textwidth-2\fboxsep}{
    \vspace{2mm}
    \begin{center}
    \textbf{\textcolor{navy}{STRATEGIC ANALYSIS}}
    \end{center}
    \vspace{1mm}
    \noindent
    <<VERDICT>>
    \vspace{2mm}
}}

\vspace{1cm}

% --- Comparison Table ---
\renewcommand{\arraystretch}{1.5}
\begin{longtable}{@{}>{\raggedright\arraybackslash}p{0.46\textwidth}|>{\raggedright\arraybackslash}p{0.46\textwidth}@{}}
    \textbf{\large 6 Months Ago (Historical)} & \textbf{\large Today (Current)} \\
    \hline
    & \\[-0.5em]

    \sectionheader{TAGLINE} & \sectionheader{TAGLINE} \\
    <<OLD_TAGLINE>> & <<NEW_TAGLINE>> \\[0.5em]

    \sectionheader{AUDIENCE} & \sectionheader{AUDIENCE} \\
    <<OLD_AUDIENCE>> & <<NEW_AUDIENCE>> \\[0.5em]

    \sectionheader{PRICING} & \sectionheader{PRICING} \\
    <<OLD_PRICING>> & <<NEW_PRICING>> \\

\end{longtable}

\vfill
\begin{center}
\footnotesize \textcolor{grey}{Generated by Sentinel AI | Confidentially Distributed}
\end{center}

\end{document}
"""


def escape_latex(text: str) -> str:
    """
    Strictly escapes special characters for LaTeX.
    """
    if not text:
        return ""

    # 1. Backslash first (Critical)
    text = text.replace('\\', r'\textbackslash{}')

    # 2. Other special chars
    replacements = {
        '&': r'\&',
        '%': r'\%',
        '$': r'\$',
        '#': r'\#',
        '_': r'\_',
        '{': r'\{',
        '}': r'\}',
        '~': r'\textasciitilde{}',
        '^': r'\textasciicircum{}',
    }

    for key, val in replacements.items():
        text = text.replace(key, val)

    # 3. Handle Newlines
    # Convert double newlines to paragraph spacing
    text = text.replace('\n\n', r' \par\vspace{0.1cm} ')
    # Convert single newlines to line breaks
    text = text.replace('\n', r' \newline ')

    return text


def format_markdown(text: str) -> str:
    """
    Converts basic markdown (**bold**) to LaTeX \textbf{}.
    """
    if not text:
        return ""
    return re.sub(r'\*\*(.*?)\*\*', r'\\textbf{\1}', text)


def pretty_domain(url: str) -> str:
    try:
        p = urllib.parse.urlparse(url)
        return p.netloc or url
    except Exception:
        return url


def format_pricing_latex(plans):
    """
    Formats pricing tiers with bold headers and indented descriptions.
    """
    if not plans:
        return "No pricing data available."

    latex_lines = []

    # Handle list of objects (New Schema)
    if isinstance(plans, list) and len(plans) > 0 and isinstance(plans[0], dict):
        for p in plans:
            name = escape_latex(p.get("name", "Plan"))
            price = escape_latex(p.get("price", "N/A"))
            mechanic = escape_latex(p.get("usage_mechanic", ""))

            # Tier header (bold name with price)
            latex_lines.append(f"\\textbf{{{name}}} ({price})")

            # Description - use newline and small text (table-cell friendly)
            if mechanic:
                latex_lines.append(f"\\newline {{\\footnotesize {mechanic}}}")
            latex_lines.append(r"\newline")

    # Handle list of strings (Old Schema)
    elif isinstance(plans, list):
        for p in plans:
            clean_p = escape_latex(str(p))
            latex_lines.append(f"{clean_p} \\newline ")

    # Handle raw string fallback
    elif isinstance(plans, str):
        latex_lines.append(escape_latex(plans))

    return " ".join(latex_lines)


def generate_tex_file(data, outfile_tex):
    result = data.get("result", {})
    old_state = result.get("old_state", {})
    new_state = result.get("new_state", {})
    analysis = result.get("analysis", {})

    competitor = escape_latex(pretty_domain(data.get("url", "Unknown")))
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')

    # Verdict keys
    raw_verdict = analysis.get("strategic_analysis") or \
        analysis.get("strategic_shift") or \
        analysis.get("summary_of_changes") or \
        "Analysis failed to generate output."
    verdict = format_markdown(escape_latex(raw_verdict))

    # Fields
    old_tagline = escape_latex(old_state.get("tagline", "N/A"))
    new_tagline = escape_latex(new_state.get("tagline", "N/A"))

    old_audience = escape_latex(old_state.get("target_audience", "N/A"))
    new_audience = escape_latex(new_state.get("target_audience", "N/A"))

    # Pricing
    old_pricing_raw = old_state.get(
        "pricing_plans") or old_state.get("pricing_tiers")
    new_pricing_raw = new_state.get(
        "pricing_plans") or new_state.get("pricing_tiers")

    old_pricing_latex = format_pricing_latex(old_pricing_raw)
    new_pricing_latex = format_pricing_latex(new_pricing_raw)

    # Inject
    tex = LATEX_TEMPLATE.replace("<<COMPETITOR>>", competitor)
    tex = tex.replace("<<TIMESTAMP>>", timestamp)
    tex = tex.replace("<<VERDICT>>", verdict)

    tex = tex.replace("<<OLD_TAGLINE>>", old_tagline)
    tex = tex.replace("<<NEW_TAGLINE>>", new_tagline)

    tex = tex.replace("<<OLD_AUDIENCE>>", old_audience)
    tex = tex.replace("<<NEW_AUDIENCE>>", new_audience)

    tex = tex.replace("<<OLD_PRICING>>", old_pricing_latex)
    tex = tex.replace("<<NEW_PRICING>>", new_pricing_latex)

    with open(outfile_tex, "w", encoding="utf-8") as f:
        f.write(tex)

    return True


def compile_pdf(tex_file):
    if not shutil.which("pdflatex"):
        print("\n❌ Error: 'pdflatex' not found.")
        print("To fix: brew install --cask basictex (on Mac)")
        return False

    try:
        # Run pdflatex
        cmd = ["pdflatex", "-interaction=nonstopmode", tex_file]

        # We allow it to 'fail' (return non-zero) because benign font warnings trigger it
        subprocess.run(cmd, stdout=subprocess.DEVNULL,
                       stderr=subprocess.DEVNULL)
        subprocess.run(cmd, stdout=subprocess.DEVNULL,
                       stderr=subprocess.DEVNULL)

        pdf_file = tex_file.replace(".tex", ".pdf")
        if os.path.exists(pdf_file) and os.path.getsize(pdf_file) > 1000:
            return True
        else:
            print("\n❌ PDF Generation Failed (Empty or missing).")
            return False

    except Exception as e:
        print(f"\n❌ Execution Error: {e}")
        return False


def poll_job(api_base: str, job_id: str, timeout: int = 300) -> dict:
    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            r = requests.get(f"{api_base}/jobs/{job_id}")
            if r.status_code == 200:
                j = r.json()
                if j.get("status") in ("completed", "failed"):
                    return j
        except requests.exceptions.ConnectionError:
            pass
        time.sleep(2)
    raise SystemExit("Timed out waiting for job.")


def main():
    parser = argparse.ArgumentParser(
        description="Generate Sentinel LaTeX Report")
    parser.add_argument("--url", required=True)
    parser.add_argument("--months", type=int, default=6)
    parser.add_argument("--api", default="http://127.0.0.1:8000")
    args = parser.parse_args()

    print(f"Submitting job for {args.url}...")
    try:
        resp = requests.post(f"{args.api}/analyze",
                             json={"url": args.url, "months": args.months})
        job = resp.json()
        job_id = job["job_id"]
        print(f"Job Queued: {job_id}")
    except Exception as e:
        print(f"Failed to contact API: {e}")
        return

    print("Waiting for analysis...")
    result_data = poll_job(args.api, job_id)

    if result_data.get("status") == "failed":
        print(f"Job Failed: {result_data.get('error')}")
        return

    safe_name = pretty_domain(args.url).replace(".", "-")
    tex_filename = f"report_{safe_name}.tex"

    print(f"Generating LaTeX source: {tex_filename}")
    generate_tex_file(result_data, tex_filename)

    print("Compiling PDF...")
    if compile_pdf(tex_filename):
        pdf_filename = tex_filename.replace(".tex", ".pdf")
        print(f"\n✅ Success! Report saved to: {pdf_filename}")
        for ext in [".aux", ".log", ".out"]:
            try:
                os.remove(tex_filename.replace(".tex", ext))
            except:
                pass
    else:
        print("DEBUG: Check the .tex file for errors.")


if __name__ == "__main__":
    main()
